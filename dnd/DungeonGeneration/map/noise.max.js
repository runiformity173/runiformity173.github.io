let temp={reset:function(){this.memory = {};this.gradients = {};},rand_vect:function(){var t=2*Math.random()*Math.PI;return{x:Math.cos(t),y:Math.sin(t)}},dot_prod_grid:function(t,r,i,n){let e;r={x:t-i,y:r-n};return this.gradients[[i,n]]?e=this.gradients[[i,n]]:(e=this.rand_vect(),this.gradients[[i,n]]=e),r.x*e.x+r.y*e.y},smootherstep:function(t){return 6*t**5-15*t**4+10*t**3},interp:function(t,r,i){return r+this.smootherstep(t)*(i-r)},seed:function(){this.gradients={},this.memory={}},get:function(t,r){if(this.memory.hasOwnProperty([t,r]))return this.memory[[t,r]];var i=Math.floor(t),n=Math.floor(r),e=this.dot_prod_grid(t,r,i,n),o=this.dot_prod_grid(t,r,i+1,n),s=this.dot_prod_grid(t,r,i,n+1),h=this.dot_prod_grid(t,r,i+1,n+1),o=this.interp(t-i,e,o),h=this.interp(t-i,s,h),h=this.interp(r-n,o,h);return this.memory[[t,r]]=h}};
const clamp = (o,m1,m2)=>(Math.min(Math.max(o,m1),m2));
let precip={reset:function(){this.memory = {};this.gradients = {};},rand_vect:function(){var t=2*Math.random()*Math.PI;return{x:Math.cos(t),y:Math.sin(t)}},dot_prod_grid:function(t,r,i,n){let e;r={x:t-i,y:r-n};return this.gradients[[i,n]]?e=this.gradients[[i,n]]:(e=this.rand_vect(),this.gradients[[i,n]]=e),r.x*e.x+r.y*e.y},smootherstep:function(t){return 6*t**5-15*t**4+10*t**3},interp:function(t,r,i){return r+this.smootherstep(t)*(i-r)},seed:function(){this.gradients={},this.memory={}},get:function(t,r){if(this.memory.hasOwnProperty([t,r]))return this.memory[[t,r]];var i=Math.floor(t),n=Math.floor(r),e=this.dot_prod_grid(t,r,i,n),o=this.dot_prod_grid(t,r,i+1,n),s=this.dot_prod_grid(t,r,i,n+1),h=this.dot_prod_grid(t,r,i+1,n+1),o=this.interp(t-i,e,o),h=this.interp(t-i,s,h),h=this.interp(r-n,o,h);return this.memory[[t,r]]=h}};
const perlin = function(x,y,a) {if (a == "temp") {return clamp(temp.get(x/50,y/50)+0.5,0,1)} else {return clamp(precip.get(x/50,y/50)+0.5,0,1)}}